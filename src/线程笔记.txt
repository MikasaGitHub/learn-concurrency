1.守护线程会随着主线程的执行完毕而退出。尽管它处于一直执行中。
2.线程是否中断,iterruptede()方法进行判断是否中断,stop方法已经过期不建议使用。
3.线程池：
(1).newFixedThreadPool(10)，始终只会有10个线程在运行。
(2).new CachedThreadPool()，如果执行任务时线程够用不创建新的线程，不够用会自动创建新的线程执行


4.synchronized关键字 修饰普通方法时内置锁是当前实例
					 修饰静态方法内置锁是当前class字节码对象
					 修饰代码块
					 
5.重入锁: 当一个类里面多个方法拥有同步方法。并一个同步方法里调用了另一个同步方法，为重入锁。
  锁的可重入，同一个线程可以多次进行lock，而不会阻塞
  自旋锁：cpu处于空转状态
  
6.volatile：修饰变量可以在多个线程中实时共享变量，线程之间是可见的.
  所谓可见就是 当一个线程修改了这个变量的值，在另一个线程中能够督导这个修改后的值
  
7.原子性操作类: private AtomicInteger value = new AtomicInteger(0);
				value.getAndIncrement(); 
				代替synchronized 也能保证线程安全
				
8. Lock 需要显示的获取锁和释放锁，繁琐能让代码更灵活，可以方便实现公平性。
   synchronized 不需要显示地获取和释放锁，简单。
   
9. Lock 里有公平锁和非公平锁。
公平锁的实现其实就是将线程放入队列里，进行先入先出的原则。
lock 实现的公平锁实现的方式是判断是否有前置节点 
而非公平锁的实现方式不需要进行这一判断
   
		     
				
 