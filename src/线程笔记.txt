1.守护线程会随着主线程的执行完毕而退出。尽管它处于一直执行中。
2.线程是否中断,iterruptede()方法进行判断是否中断,stop方法已经过期不建议使用。
3.线程池：
(1).newFixedThreadPool(10)，始终只会有10个线程在运行。
(2).new CachedThreadPool()，如果执行任务时线程够用不创建新的线程，不够用会自动创建新的线程执行


4.synchronized关键字 修饰普通方法时内置锁是当前实例
					 修饰静态方法内置锁是当前class字节码对象
					 修饰代码块
					 
5.重入锁: 当一个类里面多个方法拥有同步方法。并一个同步方法里调用了另一个同步方法，为重入锁。
  锁的可重入，同一个线程可以多次进行lock，而不会阻塞
  自旋锁：cpu处于空转状态
  
6.volatile：修饰变量可以在多个线程中实时共享变量，线程之间是可见的.
  所谓可见就是 当一个线程修改了这个变量的值，在另一个线程中能够读到这个修改后的值
  
7.原子性操作类: private AtomicInteger value = new AtomicInteger(0);
				value.getAndIncrement(); 
				代替synchronized 也能保证线程安全
				
8. Lock 需要显示的获取锁和释放锁，繁琐能让代码更灵活，可以方便实现公平性。
   synchronized 不需要显示地获取和释放锁，简单。
   
9.  Lock 里有公平锁和非公平锁。
	公平锁的实现其实就是将线程放入队列里，进行先入先出的原则。
	lock 实现的公平锁实现的方式是判断是否有前置节点 
	而非公平锁的实现方式不需要进行这一判断

10. wait和notify方法要放在同步代码块儿里使用才有效。
    等待的线程会释放锁。被唤醒的线程会拿到锁。
	
11. 同步队列:进行了lock方法的线程进入了同步队列。
	等待队列:Condition 的线程 进行了await 进入等待队列，同时因为释放锁从同步队列移出

12. Callable和Runnable的区别: Runnable run方法是由线程调用的.在run方法是异步执行的.
							  Callable 的call 不是异步执行,是由Future的run方法调用的
   		
 